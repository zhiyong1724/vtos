#ifndef __OS_MAP_H__
#define __OS_MAP_H__
#include "os_tree.h"
#include "os_list.h"
typedef struct os_map_iterator
{
	tree_node_type_def tree_node;
	list_node_type_def list_node;
} os_map_iterator;

typedef struct os_map
{
	tree_node_type_def *tree;
	list_node_type_def *head;
	os_size_t key_size;
	os_size_t value_size;
	os_size_t size;
} os_map;

/*********************************************************************************************************************
* 初始化容器
* obj 容器对象
* key_size key类型大小
* value_size value类型大小
*********************************************************************************************************************/
void os_map_init(os_map *obj, os_size_t key_size, os_size_t value_size);
/*********************************************************************************************************************
* 释放容器
* obj 容器对象
*********************************************************************************************************************/
void os_map_free(os_map *obj);
/*********************************************************************************************************************
* 获取容器大小
* obj 容器对象
*********************************************************************************************************************/
os_size_t os_map_size(os_map *obj);
/*********************************************************************************************************************
* 判断容器是否为空
* obj 容器对象
*********************************************************************************************************************/
os_size_t os_map_empty(os_map *obj);
/*********************************************************************************************************************
* 插入元素
* obj 容器对象
* key 键，因为不知道key的类型，通用设计是按字节比较的，所以如果key是字符串的话，必须对数组进行初始化
* value 值
* return 0 成功插入
*********************************************************************************************************************/
os_size_t os_map_insert(os_map *obj, void *key, void *value);
/*********************************************************************************************************************
* 查找元素
* obj 容器对象
* key 键，因为不知道key的类型，通用设计是按字节比较的，所以如果key是字符串的话，必须对数组进行初始化
* return 对应的迭代器
*********************************************************************************************************************/
os_map_iterator *os_map_find(os_map *obj, void *key);
/*********************************************************************************************************************
* 移除元素
* obj 容器对象
* itr 要移除的数据
* return 0:成功移除
*********************************************************************************************************************/
os_size_t os_map_erase(os_map *obj, os_map_iterator *itr);
/*********************************************************************************************************************
* 清空所有元素
* obj 容器对象
*********************************************************************************************************************/
void os_map_clear(os_map *obj);
/*********************************************************************************************************************
* 返回key对象
* itr 迭代器
* retuan 数据指针
*********************************************************************************************************************/
void *os_map_first(os_map_iterator *itr);
/*********************************************************************************************************************
* 返回value对象
* obj 容器对象
* itr 迭代器
* retuan 数据指针
*********************************************************************************************************************/
void *os_map_second(os_map *obj, os_map_iterator *itr);
/*********************************************************************************************************************
* 返回第一个值的迭代器
* obj 容器对象
* retuan 迭代器
*********************************************************************************************************************/
os_map_iterator *os_map_begin(os_map *obj);
/*********************************************************************************************************************
* 返回下一个迭代器
* obj 容器对象
* itr 迭代器
* retuan 下一个迭代器
*********************************************************************************************************************/
os_map_iterator *os_map_next(os_map *obj, os_map_iterator *itr);
#endif