#ifndef __OS_Q_H__
#define __OS_Q_H__
#include "sched/os_sem.h"
typedef struct os_q_t
{
	void **pp_start_index;
	void **pp_push_index;
	void **pp_pop_index;
	uint32 total_ms_count;
	uint32 cur_ms_count;
	os_sem_t sem;
} os_q_t;
/*********************************************************************************************************************
* 创建一个消息队列
* p_q：指向存储os_q_t结构的空间
* pp_start：指向保存消息指针的数组
* uint32：该消息队列可以保存的最大消息数目
* return：返回一个消息队列控制器
*********************************************************************************************************************/
os_q_t *os_q_create(os_q_t *p_q, void **pp_start, uint32 ms_count);
/*********************************************************************************************************************
* 重置消息队列，重置后消息队列的内容会丢失
* p_queue：指向要被重置的消息队列控制器
*********************************************************************************************************************/
void os_q_reset(os_q_t *p_queue);
/*********************************************************************************************************************
* 获取一个消息，该函数会阻塞线程
* p_queue：指向要获取消息的消息队列控制器
* timeout：获取超时时间，单位ms，超时后直接返回NULL，如果是0则表示不设置超时，线程被阻塞直到获取到消息
* p_status：指向一个空间，函数返回后，会把获取状态存放到这个空间上
* return：返回获取到的消息，如果获取超时，则返回NULL
*********************************************************************************************************************/
void *os_q_pend(os_q_t *p_queue, uint32 timeout, uint32 *p_status);
/*********************************************************************************************************************
* 推一条消息进消息队列
* p_queue：指向消息队列控制器
* p_msg：要进消息队列的消息指针
* return：返回消息队列中消息的数量
*********************************************************************************************************************/
uint32 os_q_post(os_q_t *p_queue, void *p_msg);
#endif
