#ifndef _VTOS_H
#define _VTOS_H
#include "os_cpu.h"
#include "sched/os_sem.h"
#include "sched/os_q.h"
#include "sched/os_sched_def.h"
/*********************************************************************************************************************
 * 系统初始化函数，使用一切系统服务之前必须先调用该函数
 * return 1:初始化失败；0：初始化成功
 *********************************************************************************************************************/
os_size_t os_sys_init(void);
/*********************************************************************************************************************
 * 系统启动函数，调用该函数以后控制权将交给系统
 *********************************************************************************************************************/
void os_sys_start(void);
/*********************************************************************************************************************
 * 返回系统的版本号
 *********************************************************************************************************************/
const char *os_version(void);
/*********************************************************************************************************************
 * 内存分配函数，和os_kfree联合使用
 * size：需要分配的内存大小
 * return：返回指向分配内存空间的指针，如果分配失败，将返回NULL
 *********************************************************************************************************************/
void *os_kmalloc(os_size_t size);
/*********************************************************************************************************************
 * 内存释放函数，该函数与os_kmalloc联合使用
 * addr：指向要释放内存的指针
 *********************************************************************************************************************/
void os_kfree(void *addr);
/*********************************************************************************************************************
 * return：返回交给系统管理的所有内存大小
 *********************************************************************************************************************/
os_size_t os_total_mem_size(void);
/*********************************************************************************************************************
 * return：返回由os_malloc和os_kmalloc分配的内存大小
 *********************************************************************************************************************/
os_size_t os_used_mem_size(void);
/*********************************************************************************************************************
 * 该函数是一个系统时钟函数，用来给系统提供时钟节拍，需要定时被调用，或者被映射为中断函数
 *********************************************************************************************************************/
void os_sys_tick(void);
/*********************************************************************************************************************
 * 创建一个新的线程
 * task：指向线程函数
 * p_arg：传递给线程的参数
 * name：线程名称
 * return: 1：创建失败，0：创建成功
 *********************************************************************************************************************/
os_size_t os_kthread_create(void (*task)(void *p_arg), void *p_arg, const char *name);
/*********************************************************************************************************************
 * 创建一个新的线程
 * task：指向线程函数
 * p_arg：传递给线程的参数
 * name：线程名称
 * stack_size：指定线程栈的大小
 * return: 1：创建失败，0：创建成功
 *********************************************************************************************************************/
os_size_t os_kthread_createEX(void (*task)(void *p_arg), void *p_arg, const char *name, os_size_t stack_size);
/*********************************************************************************************************************
 * 改变自身的优先级，优先级越低，获得的运行时间越多，默认的优先级为0
 * prio：线程的优先级，范围为-20到19
 *********************************************************************************************************************/
void os_set_prio(int32 prio);
/*********************************************************************************************************************
 * return：返回系统的所有线程数
 *********************************************************************************************************************/
os_size_t os_total_thread_count(void);
/*********************************************************************************************************************
 * return：返回系统的活动线程数
 *********************************************************************************************************************/
os_size_t os_activity_thread_count(void);
/*********************************************************************************************************************
 * 线程睡眠函数
 * 睡眠的时间，单位为ms
 *********************************************************************************************************************/
void os_sleep(uint64 t);
/*********************************************************************************************************************
 * 创建一个新的信号量
 * p_sem：指向一个存放os_sem_t结构的空间
 * cnt：该信号量初始的信号个数
 * return：返回新的信号量
 *********************************************************************************************************************/
os_sem_t *os_sem_create(os_sem_t *p_sem, uint32 cnt);
/*********************************************************************************************************************
 * 获取一个信号，阻塞线程
 * p_sem：指向要获取信号的信号量
 * timeout：获取超时时间，单位ms，超时后直接返回，如果是0则表示不设置超时，线程被阻塞直到获取到信号
 * p_status：指向一个空间，函数返回后，会把获取状态存放到这个空间上
 *********************************************************************************************************************/
void os_sem_pend(os_sem_t *p_sem, uint64 timeout, uint32 *p_status);
/*********************************************************************************************************************
 * 释放出一个信号
 * p_sem：指向要释放信号的信号量
 *********************************************************************************************************************/
uint32 os_sem_post(os_sem_t *p_sem);
/*********************************************************************************************************************
 * 创建一个消息队列
 * p_q：指向存储os_q_t结构的空间
 * pp_start：指向保存消息指针的数组
 * uint32：该消息队列可以保存的最大消息数目
 * return：返回一个消息队列控制器
 *********************************************************************************************************************/
os_q_t *os_q_create(os_q_t *p_q, void **pp_start, uint32 ms_count);
/*********************************************************************************************************************
 * 重置消息队列，重置后消息队列的内容会丢失
 * p_queue：指向要被重置的消息队列控制器
 *********************************************************************************************************************/
void os_q_reset(os_q_t *p_queue);
/*********************************************************************************************************************
 * 获取一个消息，该函数会阻塞线程
 * p_queue：指向要获取消息的消息队列控制器
 * timeout：获取超时时间，单位ms，超时后直接返回NULL，如果是0则表示不设置超时，线程被阻塞直到获取到消息
 * p_status：指向一个空间，函数返回后，会把获取状态存放到这个空间上
 * return：返回获取到的消息，如果获取超时，则返回NULL
 *********************************************************************************************************************/
void *os_q_pend(os_q_t *p_queue, uint32 timeout, uint32 *p_status);
/*********************************************************************************************************************
 * 推一条消息进消息队列
 * p_queue：指向消息队列控制器
 * p_msg：要进消息队列的消息指针
 * return：返回消息队列中消息的数量
 *********************************************************************************************************************/
uint32 os_q_post(os_q_t *p_queue, void *p_msg);
#endif
