#ifndef __VTOS_H__
#define __VTOS_H__
#include "os_cpu.h"
#include "sched/os_sem.h"
#include "sched/os_q.h"
#include "sched/os_sched.h"
#include "mem/os_mem.h"
/*********************************************************************************************************************
* 判断CPU字节序是否为小端模式
* return：1：小端模式；0：大端模式
*********************************************************************************************************************/
uint32 is_little_endian();
/*********************************************************************************************************************
* 返回系统的版本号
*********************************************************************************************************************/
const char *os_version(void);
/*********************************************************************************************************************
 * 系统初始化函数，使用一切系统服务之前必须先调用该函数
 * return 1:初始化失败；0：初始化成功
 *********************************************************************************************************************/
os_size_t os_sys_init(void);
/*********************************************************************************************************************
 * 系统启动函数，调用该函数以后控制权将交给系统
 *********************************************************************************************************************/
void os_sys_start(void);
/*********************************************************************************************************************
 * 创建一个消息队列
 * p_q：指向存储os_q_t结构的空间
 * pp_start：指向保存消息指针的数组
 * uint32：该消息队列可以保存的最大消息数目
 * return：返回一个消息队列控制器
 *********************************************************************************************************************/
os_q_t *os_q_create(os_q_t *p_q, void **pp_start, uint32 ms_count);
/*********************************************************************************************************************
 * 重置消息队列，重置后消息队列的内容会丢失
 * p_queue：指向要被重置的消息队列控制器
 *********************************************************************************************************************/
void os_q_reset(os_q_t *p_queue);
/*********************************************************************************************************************
 * 获取一个消息，该函数会阻塞线程
 * p_queue：指向要获取消息的消息队列控制器
 * timeout：获取超时时间，单位ms，超时后直接返回NULL，如果是0则表示不设置超时，线程被阻塞直到获取到消息
 * p_status：指向一个空间，函数返回后，会把获取状态存放到这个空间上
 * return：返回获取到的消息，如果获取超时，则返回NULL
 *********************************************************************************************************************/
void *os_q_pend(os_q_t *p_queue, uint32 timeout, uint32 *p_status);
/*********************************************************************************************************************
 * 推一条消息进消息队列
 * p_queue：指向消息队列控制器
 * p_msg：要进消息队列的消息指针
 * return：返回消息队列中消息的数量
 *********************************************************************************************************************/
uint32 os_q_post(os_q_t *p_queue, void *p_msg);
#endif
